---
title: 渲染原理解析
nav:
  title: 基础沉淀
  path: /article
group:
  path: /browser
  title: 浏览器
  order: 2
order: 1
---

# 渲染原理解析

## 浏览器内核

现代浏览器是多进程架构，其中进程中又包含了多个线程，而处理 html 解析和页面渲染主要就发生在渲染进程中，就是我们常说的浏览器内核，渲染进程主要包括了 GUI 渲染线程、js 引擎线程、事件触发线程、定时触发线程、异步请求线程等。

### 渲染进程

渲染线程主要负责页面的渲染工作，解析 html、css、构建布局树、绘制图层等操作。

### JS 引擎线程

JS 引擎线程是浏览器用来执行 js 的解释器，常见的一种实现方式就是 V8 引擎。 JS 引擎线程和渲染线程互斥，即同时只能有一个线程在执行。 这是因为 JS 可以对 DOM 节点进行增删改，所以如果在渲染的过程中，JS 同时修改了 DOM，就会不断的重复渲染， 所以 JS 引擎在设计之初就设计了两者互斥，当 JS 引擎工作的时候，渲染线程就挂起等待， 这就导致了我们经常遇到的一个问题，当 js 执行时间过长会造成页面卡顿。

### 事件触发线程

我们知道 JS 是靠事件驱动的语言，它是单线程，异步执行的。主要处理浏览器的各种事件，比如点击事件，移动事件，然后将事件放入任务队列末尾等待 JS 引擎执行。

### 定时触发线程

主要负责处理 JS 中的定时器，因为 JS 引擎是单线程的，可能存在阻塞的情况，所以再开一个线程负责可以保证定时器的准确性。 当然我们通常通过回调函数执行定时的事件，而回调事件触发后会被加入任务队列末尾等待执行，所以如果 JS 引擎阻塞后，具体的执行时间还是会有误差。

### 异步请求线程

当有 XMLHttpRequest 请求时，会新开线程发出请求，等返回状态变更时，会触发回调事件，将事件放入任务队列等待 JS 引擎执行。

<img width="763" alt="截屏2022-05-12 12 57 23" src="https://user-images.githubusercontent.com/36124772/167996663-eaea394f-c949-4e69-ab04-babb58d5bd6e.png">

## life of frame

页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60 帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的（16.6ms） 过程中浏览器又干了些什么呢？

![E2jyGxNbFpz7QXg](https://user-images.githubusercontent.com/36124772/167997363-b052783a-a5d8-41aa-838a-18df6771c2af.png)

- 接受输入事件
- 执行事件回调
- 开始一帧
- 执行 RAF (RequestAnimationFrame)
- 页面布局，样式计算
- 绘制渲染
- 执行 RIC (RequestIdelCallback)

## 页面请求加载过程

在浏览器地址栏输入域名开始，

### DNS 查询

浏览器向 DNS 服务器发起 DNS 查询请求，最终得到一个 IP 地址（IP 地址与域名一一对应）。然后浏览器向该 IP 发送 HTTP 请求。

### TCP 握手

一旦获取到服务器 IP 地址，浏览器就会通过 [TCP`三次握手`](https://mp.weixin.qq.com/s/ANBpgkprBbB3g1UgvvOBjw)与服务器建立连接。

### TSL 协商

为了在 HTTPS 上建立安全连接，另一种握手是必须的。更确切的说是 TLS 协商，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。

虽然建立安全连接对增加了加载页面的等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和 web 服务器之间传输的数据不可以被第三方解密。

### 服务器响应

一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。

初始请求的响应包含所接收数据的第一个字节。`Time to First Byte（TTFB）`是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 14KB 的数据。

## TCP 慢开始 / 14kb 规则

数据在传输过程中不是一次性传输的，第一个响应包是 14kb 大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。

在"TCP slow start"中，在收到初始包之后, 服务器会将下一个包的大小加倍到大约 28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。

初始页面加载的 14Kb 规则，TCP 慢开始就是初始响应为 14Kb 的原因，也是为什么 web 性能优化需要将此初始 14Kb 响应作为优化重点的原因。TCP 慢开始逐渐建立适合网络能力的传输速度，以避免拥塞。

一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。“解析”是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。

即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。这就是为什么在前 14Kb 中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript 必须被解析完成。

## 浏览器渲染过程

### 构建 DOM 树

DOM 树描述了文档的内容。html 元素是第一个标签也是文档树的根节点。树反映了不同标记之间的关系和层次结构。嵌套在其他标记中的标记是子节点。DOM 节点的数量越多，构建 DOM 树所需的时间就越长。

### 构建 CSSOM 树

CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树. 它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

### 构建渲染树

这一步是将 DOM 和 CSSOM 组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。

像 header 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。

每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。

### Layout（布局）

这一步是在渲染树上运行布局以计算每个节点的几何体，确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。

第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流。

### Paint（渲染）

最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为 first meaningful paint。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。浏览器需要非常快地完成这项工作。

### Compositing（合成）

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

## css 和 js 的加载

在解析 HTML 的过程中，遇到需要加载的资源特点如下：

- CSS <style>不会阻塞 dom 树的构建和页面的渲染，所以当 style 标签的内容过多时会出现闪屏现象。
- CSS <link>资源异步下载，下载和解析都不会阻塞构建 dom 树<link href='./style.css' rel='stylesheet'/>，但会阻塞页面的渲染。
- JS 资源同步下载，下载和执行都会阻塞构建 dom 树<script src='./index.js'/>
- 另外一点就是，CSS <link>资源异步下载，下载和解析也不会阻塞 js 资源的下载和执行，但是当 js 有操作 cssom 树时，js 执行就会被阻塞，这时 CSS 有就阻塞了 HTML 的解析。

![08a0f790380d6d8d6c5e9642ae22a78e](https://user-images.githubusercontent.com/36124772/164715633-c73b005e-6c50-435f-bdc6-15bcd177b762.png)

## js 脚本引入时 async 和 defer 有什么差别

预加载扫描器解决了 JS 同步加载阻塞 HTML 解析的问题，但是我们还没有解决 JS 执行阻塞 HTML 解析的问题。所有有了 async 和 defer 属性。

- 没有 defer 或 async，浏览器会立即加载并执行指定的脚本
- async 属性表示异步执行引入的 JavaScript，经加载好，就会开始执行
- defer 属性表示延迟到 DOM 解析完成，再执行引入的 JS

![2a42d577992177ce858a0665a696502e](https://user-images.githubusercontent.com/36124772/164715683-cefe2dc3-8257-4549-ac01-cf3794774f4b.png)
